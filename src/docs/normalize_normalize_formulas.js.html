<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: normalize/normalize_formulas.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: normalize/normalize_formulas.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const _ = require('lodash');
const { global_parameters } = require('../utils/global_parameters.js');

let charge_new_time = 0;
let charge_old_time = 0;
let discharge_new_time = 0;
let discharge_old_time = 0;
let record_start_new = new Date();
let record_start_old = null;
let seconds_charge_old = 0;
let seconds_discharge_old = 0;
let seconds_equal_old = 0;
let seconds_greater_old = 0;
let seconds_less_old = 0;

function calculateChargeCapacity(value) {
    if (global_parameters.profile === 'hh') {
        const [capacity] = value;
        if (_.toNumber(capacity) &amp;&amp; capacity >= 0) return capacity;
        return null;
    } else if (global_parameters.profile === 'regatron') {
        const [time, current] = value;
        if (!_.isNaN(time)) {
            charge_new_time = time - charge_old_time;
            charge_old_time = time;
        }
        if (_.toNumber(current) &amp;&amp; current >= 0) return charge_new_time * current;
        return null;
    } else if (global_parameters.profile === 'bk') {
        const [action, capacity] = value;
        if (_.toLower(action) === 'charge') {
            if (_.isNil(capacity)) return null;
            return capacity;
        }
        return null;
    } else if (global_parameters.profile === 'itech') {
        const [capacity] = value;
        if (_.toNumber(capacity) &amp;&amp; capacity >= 0) return capacity;
        return null;
    }
}

function calculateChargeEnergy(value) {
    if (global_parameters.profile === 'bk') {
        const [action, capacity] = value;
        if (_.toLower(action) === 'charge') {
            if (_.isNil(capacity)) return null;
            return capacity;
        }
        return null;
    }
}

function calculateDischargeCapacity(value) {
    if (global_parameters.profile === 'hh') {
        const [capacity] = value;
        if (_.toNumber(capacity) &amp;&amp; capacity &lt; 0) return capacity;
        return null;
    } else if (global_parameters.profile === 'regatron') {
        const [time, current] = value;
        if (!isNaN(time)) {
            discharge_new_time = time - discharge_old_time;
            discharge_old_time = time;
        }
        if (_.toNumber(current) &amp;&amp; current &lt; 0) return discharge_new_time * current;
        return null;
    } else if (global_parameters.profile === 'bk') {
        const [action, capacity] = value;
        if (_.toLower(action) === 'discharge(cc)') {
            if (_.isNil(capacity)) return null;
            return capacity;
        }
        return null;
    } else if (global_parameters.profile === 'itech') {
        const [capacity] = value;
        if (_.toNumber(capacity) &amp;&amp; capacity &lt; 0) return capacity;
        return null;
    }
}

function calculateDischargeEnergy(value) {
    if (global_parameters.profile === 'bk') {
        const [action, capacity] = value;
        if (_.toLower(action) === 'discharge(cc)') {
            if (_.isNil(capacity)) return null;
            return capacity;
        }
        return null;
    }
}

function calculateStepTime(value) {
    if (global_parameters.profile === 'bk') {
        const [action, date_time] = value;
        if (_.toLower(action) === 'charge') {
            seconds_discharge_old = 0;
            const seconds_new = date_time.getTime() / 1000;
            if (seconds_charge_old === 0) seconds_charge_old = seconds_new;
            return seconds_new - seconds_charge_old;
        } else if (_.toLower(action) === 'discharge(cc)') {
            seconds_charge_old = 0;
            const seconds_new = date_time.getTime() / 1000;
            if (seconds_discharge_old === 0) seconds_discharge_old = seconds_new;
            return seconds_new - seconds_discharge_old;
        }
    } else if (global_parameters.profile === 'itech') {
        const [current, test_time] = value;
        if (current > 0) {
            seconds_less_old = 0;
            seconds_equal_old = 0;
            if (seconds_greater_old === 0) seconds_greater_old = 1 + test_time;
            return 1 + test_time - seconds_greater_old;
        } else if (current &lt; 0) {
            seconds_greater_old = 0;
            seconds_equal_old = 0;
            if (seconds_less_old === 0) seconds_less_old = 1 + test_time;
            return 1 + test_time - seconds_less_old;
        } else if (current === 0) {
            seconds_greater_old = 0;
            seconds_less_old = 0;
            if (seconds_equal_old === 0) seconds_equal_old = 1 + test_time;
            return 1 + test_time - seconds_equal_old;
        }
    }
}

function calculateTestTime(value) {
    if (global_parameters.profile === 'hh') {
        const [record_start, step_time] = value;
        if (record_start_old === null) record_start_old = record_start.getTime();
        const new_record_start = new Date(record_start).getTime();
        const new_step_time = _.round(step_time);
        return (new_record_start - record_start_old) / 1000 + new_step_time;
    } else if (global_parameters.profile === 'itech') {
        const [save_time] = value;
        const new_save_time = new Date(save_time);
        if (record_start_old === null) record_start_old = new_save_time.getTime();
        return (new_save_time.getTime() - record_start_old) / 1000;
    }
}

function convertTextToNumber(value, params) {
    const [from, to] = params;
    const number_value = Number(_.replace(value.trim(), from, to));
    return isNaN(number_value) ? value : number_value;
}

/**
 * Calcula a diferença em segundos entre duas datas.
 *
 * @param {Array&lt;Date>} values
 * Array contendo as duas datas para cálculo da diferença.
 *
 * @returns {number}
 * A diferença em segundos entre as duas datas.
 */
function differenceInSecondsBetweenDates(values) {
    const [first_date, second_date] = values;
    if (_.isDate(first_date) &amp;&amp; _.isDate(second_date)) {
        return Math.abs(first_date.getTime() - second_date.getTime()) / 1000;
    }
}

/**
 * Divide o primeiro valor do array values pelo primeiro valor do array params
 * ou divide o primeiro valor pelo segundo valor do array values.
 *
 * @param {Array} values
 * Array contendo o valor do dividendo ou os valores do dividendo e do divisor.
 *
 * @param {Array&lt;number>} params
 * Array contendo o valor do divisor.
 *
 * @returns {number}
 * O resultado da divisão.
 */
function divideOneByOther(values, params) {
    if (_.isEmpty(values)) return 0;
    if (values.length === 2) {
        if (!_.every(values, _.isNumber)) return 0;
        const [dividend, divisor] = values;
        const isNanOrInfinity = _.isNaN(dividend / divisor) || !_.isFinite(dividend / divisor);
        return isNanOrInfinity ? 0 : dividend / divisor;
    } else {
        if (_.isEmpty(params)) return 0;
        if (!_.every(values, _.isNumber)) return 0;
        const [dividend] = values;
        const [divisor] = params;
        const isNanOrInfinity = _.isNaN(dividend / divisor) || !_.isFinite(dividend / divisor);
        return isNanOrInfinity ? 0 : dividend / divisor;
    }
}

function extractRecordStart(value) {
    if (global_parameters.profile === 'hh') {
        const data_value = value.toString();
        const regex = /record start at [a-z]+, (.*), (.*)/;
        const match = data_value.match(regex);
        if (match &amp;&amp; match.length > 1) {
            const data = match[1];
            const hora = _.replace(match[2], /\./g, ':');
            record_start_new = new Date(`${data} ${hora}`);
        }
        return record_start_new;
    } else if (global_parameters.profile === 'regatron') {
        const data_value = global_parameters.file_name.toString();
        const regex = /(.{10})T(.{8})/;
        const match = data_value.match(regex);
        if (match &amp;&amp; match.length > 1) {
            const data = match[1];
            const hora = _.replace(match[2], /_/g, ':');
            record_start_new = new Date(`${data} ${hora}`);
        }
        return record_start_new;
    } else if (global_parameters.profile === 'bk') {
        const [start_value, data_value] = value;
        if (_.toLower(start_value) === 'start time') {
            const regex = /(.{2})\/(.{2})\/(.{4}) (.{8})/;
            const match = data_value.match(regex);
            const data = `${match[3]}-${match[2]}-${match[1]}`;
            const hora = match[4];
            record_start_new = new Date(new Date(`${data} ${hora}`));
        }
        return record_start_new;
    } else if (global_parameters.profile === 'digatron') {
        const [start_value, data_value] = value;
        if (_.toLower(start_value) === 'start time') {
            record_start_new = new Date(_.trim(data_value));
        }
        return record_start_new;
    }
}

/**
 * Multiplica todos os valores passados como parâmetro.
 *
 * @param {Array} values
 * Array contendo os valores a serem multiplicados.
 *
 * @returns {number}
 * O resultado da multiplicação dos valores.
 */
function multiplyValues(values) {
    if (!_.every(values, _.isNumber)) return 0;
    return _.reduce(values, (acc, value) => acc * value, 1);
}

function recordDate(value) {
    let [date_time, step_time] = value;
    if (global_parameters.profile === 'hh') {
        const new_date_time = new Date(date_time).getTime();
        return new Date(new_date_time + _.round(step_time) * 1000);
    } else if (global_parameters.profile === 'regatron') {
        const new_date_time = new Date(date_time).getTime();
        return new Date(new_date_time + step_time * 1000);
    } else if (global_parameters.profile === 'bk') {
        let new_date_time;
        if (/(.{10}) (.{8})/.test(date_time)) {
            const regex = /(.{2})\/(.{2})\/(.{4}) (.{8})/;
            const match = date_time.match(regex);
            const data = `${match[3]}-${match[2]}-${match[1]}`;
            const hora = match[4];
            new_date_time = new Date(`${data} ${hora}`);
            return new_date_time;
        }
    } else if (global_parameters.profile === 'digatron') {
        const new_date_time = new Date(date_time);
        if (!_.isNil(step_time)) {
            const [horas, minutos, segundos] = step_time.split(':');
            const new_step_time = parseInt(horas) * 3600 + parseInt(minutos) * 60 + parseInt(segundos);
            return new Date(new_date_time.setSeconds(new_date_time.getSeconds() + new_step_time));
        }
    }
}

/**
 * Retorna um determinado item a partir do objeto params fornecido.
 * Se o item for uma chave do objeto params e seu valor for um array,
 * retorna o primeiro elemento do array, senão, retorna o seu valor.
 * Se o item não for uma chave do objeto params, retorna o próprio item.
 *
 * @param {*} value -
 * O nome da chave ou o valor para gravação.
 *
 * @param {Object} params
 * O objeto global_parameters com os valores para gravação.
 *
 * @returns {any}
 * O valor para a gravação.
 */
function recordValue(value, params) {
    if (_.has(params, value)) {
        return _.isArray(params[value]) ? params[value][0] : params[value];
    } else {
        return value;
    }
}

function returnValue(value, params) {
    if (_.isEmpty(params)) {
        return _.isNil(value[0]) ? null : value[0];
    } else if (_.isEmpty(value)) {
        return _.isNil(params[0]) ? null : params[0];
    }
}

const normalize_formulas = {
    calculateChargeCapacity,
    calculateChargeEnergy,
    calculateDischargeCapacity,
    calculateDischargeEnergy,
    calculateStepTime,
    calculateTestTime,
    convertTextToNumber,
    differenceInSecondsBetweenDates,
    divideOneByOther,
    extractRecordStart,
    multiplyValues,
    recordDate,
    recordValue,
    returnValue
};

module.exports = normalize_formulas;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#addValues">addValues</a></li><li><a href="global.html#addValuesIfNeeded">addValuesIfNeeded</a></li><li><a href="global.html#changeValues">changeValues</a></li><li><a href="global.html#changeValuesIfNeeded">changeValuesIfNeeded</a></li><li><a href="global.html#chunkSplit">chunkSplit</a></li><li><a href="global.html#closeConnection">closeConnection</a></li><li><a href="global.html#convertDateIfNeeded">convertDateIfNeeded</a></li><li><a href="global.html#convertSpreadsheets">convertSpreadsheets</a></li><li><a href="global.html#convertToLowercase">convertToLowercase</a></li><li><a href="global.html#convertValues">convertValues</a></li><li><a href="global.html#convertValuesIfNeeded">convertValuesIfNeeded</a></li><li><a href="global.html#converteDate">converteDate</a></li><li><a href="global.html#create">create</a></li><li><a href="global.html#createCluster">createCluster</a></li><li><a href="global.html#createTable">createTable</a></li><li><a href="global.html#database">database</a></li><li><a href="global.html#differenceInSecondsBetweenDates">differenceInSecondsBetweenDates</a></li><li><a href="global.html#divideOneByOther">divideOneByOther</a></li><li><a href="global.html#fileExtension">fileExtension</a></li><li><a href="global.html#flattenData">flattenData</a></li><li><a href="global.html#getFileName">getFileName</a></li><li><a href="global.html#mapObject">mapObject</a></li><li><a href="global.html#mapObjectIfNeeded">mapObjectIfNeeded</a></li><li><a href="global.html#multiplyValues">multiplyValues</a></li><li><a href="global.html#normalize">normalize</a></li><li><a href="global.html#openConnection">openConnection</a></li><li><a href="global.html#parseToObject">parseToObject</a></li><li><a href="global.html#read">read</a></li><li><a href="global.html#readFolder">readFolder</a></li><li><a href="global.html#readSpreadsheet">readSpreadsheet</a></li><li><a href="global.html#readSpreadsheets">readSpreadsheets</a></li><li><a href="global.html#recordValue">recordValue</a></li><li><a href="global.html#removeInvalidData">removeInvalidData</a></li><li><a href="global.html#removeInvalidDataIfNeeded">removeInvalidDataIfNeeded</a></li><li><a href="global.html#removeWhitespace">removeWhitespace</a></li><li><a href="global.html#renameKeys">renameKeys</a></li><li><a href="global.html#renameKeysIfNeeded">renameKeysIfNeeded</a></li><li><a href="global.html#updateStatus">updateStatus</a></li><li><a href="global.html#writeData">writeData</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Sun Oct 22 2023 10:46:43 GMT-0300 (Horário Padrão de Brasília)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
